using Practice.Data.Dto;

namespace Practice.Services.CheckerService
{
    /// 
    /// У тебя есть специальный сервис для проверки используется ли email 
    /// и ты как бы подразумеваешь используйте это, чтобы <see cref="AuthService.IAuthService"/> не кидало ошибок.
    /// но это не как не ограничивает просто использование сервиса без предстоящих проверок
    ///
    /// Такая проверка задача самого сервиса, а не вызывающего.
    /// Тогда есть задача описания ошибок :
    ///     1 тут ты либо создаешь исключения и кидаешь их вообще везде,
    ///         а вызывающие, либо просто мидлвара ловят их и мапают к описаниям ошибок клиенту
    ///     2 либо используешь ошибки в возращаемых значениях, можно юзать всякие
    ///         - "discriminated unions" типо OneOf  (https://github.com/mcintyre321/OneOf)
    ///         - куча контейнеров результата из функциональщины на любой вкус (https://github.com/louthy/language-ext),
    ///             здесь можно внезапно стать функциональщиком на свой страх и риск
    ///         - а проще всего самому написать там минимум работы
    ///
    /// Упарываться во 2-е не стоит, нужно разничать
    ///     исключительное поведение - невозможный, неожиданный сценарий    - классно заходят exceptions 
    ///     альтернативное поведение - ожидаемый, неудачный сценарий        - подойдут ошибки в возврате
    ///
    /// ** относится ко всем 'CheckerService'

    public interface IRegisterCheckerService
    {
        public Task<bool> IsEmailExists(string login);
    }
}